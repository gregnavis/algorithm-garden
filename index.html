<!DOCTYPE html>

<html>
<head>
  <title>Algorithm Garden</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="algorithm-garden">Algorithm Garden</h1>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>The goal of the Algorithm Garden is to demonstrate simple implementations
of the core compute science algorithms. The implementation language is C
because it gives great control over the machine and is simple to write and
understand.</p>
<h1 id="includes">Includes</h1>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;stdbool.h&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;string.h&gt;</span></pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h1 id="helpers">Helpers</h1>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>A macro to swap the values of two <code>int</code>s.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> swap(x, y) do { int t = (x); x = (y); y = t; } while (0);</span></pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h1 id="minimum-and-maximum">Minimum and maximum</h1>

            </div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Finding a minimum and a maximum of an array of numbers are operations that
can be completed in linear time. The implementations are very similar to each
other. In fact one can implement a general <code>min</code> procedure that finds a
minimum of any totally ordered set. Here we take a more direct approach and
assume the natural ordering of integers.</p>
<h2 id="index-of-minimum">Index of minimum</h2>

            </div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>The procedure stores the index of an element with minimum value in <code>result</code>
and returns <code>1</code>.  If the minimum doesn&#39;t exist then <code>0</code> is returned.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">int</span> min_index(<span class="hljs-keyword">int</span> A[], size_t n, size_t *result)
{</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>An empty array doesn&#39;t have a minimum thus an error is reported.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (!n) {
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>The minimum of a subarray <code>A[0..i]</code>. Initially <code>i = 0</code> so <code>m = 0</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	size_t m = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>We iterate over the remaining elements and update the minimum in each
iteration.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">1</span>; i &lt; n; i++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>If the current <code>i</code>-th element is lower than the current
minimum then it becomes the new minimum.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (A[i] &lt; A[m]) {
			m = i;
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Save the result and return success.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	*result = m;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h2 id="minimum">Minimum</h2>

            </div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>The procedure stores the value of a minimum in <code>result</code> and returns <code>1</code>. If
the minimum doesn&#39;t exist then <code>0</code> is returned.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">int</span> min(<span class="hljs-keyword">int</span> A[], size_t n, <span class="hljs-keyword">int</span> *result)
{</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>The index of a minimum (if it exists).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	size_t index;</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Find the index of a minimum. If it doesn&#39;t exist then return an
error.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (!min_index(A, n, &amp;index)) {
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Save the value of the minimum and return success.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	*result = A[index];
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <h2 id="index-of-maximum">Index of maximum</h2>

            </div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>This is identical to <code>min_index</code> with the exception of <code>&gt;</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">int</span> max_index(<span class="hljs-keyword">int</span> A[], size_t n, size_t *result)
{
	<span class="hljs-keyword">if</span> (!n) {
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}

	size_t m = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">1</span>; i &lt; n; i++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p><code>&gt;</code> below is the only difference between <code>min_index</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (A[i] &gt; A[m]) {
			m = i;
		}
	}

	*result = m;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <h2 id="maximum">maximum</h2>

            </div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Again this is identical to <code>min</code> with the exception of using <code>max_index</code>
instead of <code>min_index</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">int</span> max(<span class="hljs-keyword">int</span> A[], size_t n, <span class="hljs-keyword">int</span> *result)
{
	size_t index;

	<span class="hljs-keyword">if</span> (!max_index(A, n, &amp;index)) {
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}

	*result = A[index];
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <h1 id="sorting">Sorting</h1>

            </div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <h2 id="selection-sort">Selection sort</h2>

            </div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Selection sort sorts an array by iterating over the elements of an array in
search for an element appropriate for the current position. It <em>selects</em> an
element to place in the current position.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">void</span> selection_sort(<span class="hljs-keyword">int</span> A[], size_t n)
{</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p><code>i</code> is the index of the current position.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	size_t i;</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Iterate over all positions except the last one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; n; i++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p><code>m</code> is the index of a minimum of <code>A[i..n - 1]</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		size_t m;</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Find the right value of <code>m</code>. No need to check for errors
because the array is non-empty if the loop is iterating.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		min_index(A + i, n - i, &amp;m);</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Place the discovered element into its correct position.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		swap(A[i], A[m]);
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <h2 id="insertion-sort">Insertion sort</h2>

            </div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Insertion sort sorts by iterating over positions of the array in order to
find the right one for the current element. The algorithm <em>inserts</em> an
element into the right place.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">void</span> insertion_sort(<span class="hljs-keyword">int</span> A[], size_t n)
{</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p><code>i</code> is the index of an element that we&#39;re placing into the right
position.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	size_t i;</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Iterate over all elements.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">1</span>; i &lt; n; i++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Move the current element to the left</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (size_t j = i; j &gt; <span class="hljs-number">0</span>; j--) {</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>If the element to the left is greater than the
current element then swap them. This brings us closer
to the sorted order.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (A[j - <span class="hljs-number">1</span>] &gt; A[j]) {
				swap(A[j], A[j + <span class="hljs-number">1</span>]);
			} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>If the elements are in the correct relative
order then we found the right position for
the <code>i</code>-th element.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">break</span>;
			}
		}
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <h2 id="quicksort">Quicksort</h2>

            </div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>The procedure <code>partition</code> places the last element of <code>A</code> into the correct
position. It&#39;s a building block of the Quicksort algorithm.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>size_t partition(<span class="hljs-keyword">int</span> A[], size_t n)
{</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p><code>x</code> is the so called pivot - the element to place in the right
position.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">int</span> x = A[n - <span class="hljs-number">1</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>The elements <code>L = A[0..p - 1]</code> are <code>&lt; x</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	size_t p = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>The elements <code>R = A[p..q - 1]</code> are <code>&gt; x</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	size_t q = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Iterate over all elements of the array except the last.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; n; i++) {
		<span class="hljs-keyword">if</span> (A[i] &lt; x) {</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Add the <code>i</code>-th element to <code>L</code> and shift <code>R</code> to the
right.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			swap(A[p], A[i]);
			p++;
			q++;
		} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>Add the <code>i</code>-th element to <code>R</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			swap(A[q], A[i]);
			q++;
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Put the pivot into the right place and return its index.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	swap(A[n - <span class="hljs-number">1</span>], A[p]);

	<span class="hljs-keyword">return</span> p;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>The quicksort algorithm sorts by putting the pivot into the right place and
sorting the two subarrays recursively. Note that this is a randomised variant
of the algorithm.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">void</span> quicksort(<span class="hljs-keyword">int</span> A[], size_t n)
{</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>Nothing to do for an empty array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (!n) {
		<span class="hljs-keyword">return</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Randomise the pivot.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	swap(A[rand() % n], A[n - <span class="hljs-number">1</span>]);</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>Place the pivot into the correct position <code>p</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	size_t p = partition(A, n);</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Sort the left and right subarrays.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	quicksort(A, p);
	quicksort(A + p + <span class="hljs-number">1</span>, n - p - <span class="hljs-number">1</span>);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <h2 id="bubble-sort">Bubble sort</h2>

            </div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Bubble sort sorts by moving elements to the right unless a sorted order is
achieved.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">void</span> bubble_sort(<span class="hljs-keyword">int</span> A[], size_t n)
{
	<span class="hljs-keyword">bool</span> is_sorted;

	<span class="hljs-keyword">do</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>We assume that the array is sorted unless we make a swap (see
below).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		is_sorted = <span class="hljs-keyword">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>Bubble all elements to the right.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; n; i++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Move the element to the right until a greater element
is found.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (A[i] &gt; A[i + <span class="hljs-number">1</span>]) {
				swap(A[i], A[i + <span class="hljs-number">1</span>]);</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>Another iteration of the outer loop is
required!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				is_sorted = <span class="hljs-keyword">false</span>;
			}
		}
	} <span class="hljs-keyword">while</span> (!is_sorted);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <h2 id="counting-sort">Counting sort</h2>

            </div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>Counting sort is an example of linear time sorting algorithms. It assumes
that the keys are small integers and sorts by counting the occurences of each
key.</p>
<p>The procedure below is a helper used by the main procedure. Here <code>A</code> and <code>n</code>
is the input array and its size, <code>k</code> is the maximum value of an element in
<code>A</code> and <code>B</code> is the output array (of size <code>n</code>).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> do_counting_sort(<span class="hljs-keyword">int</span> A[], size_t n, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> B[])
{</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p><code>C</code> is an array used to count the number of occurences of the keys.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">int</span> *C = <span class="hljs-built_in">calloc</span>(k, <span class="hljs-keyword">sizeof</span>(size_t));</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>Count the occurences of the keys.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; n; i++) {
		C[A[i]]++;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>Count the number of elements less or equal to a particular element.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; k; i++) {
		C[i] += C[i - <span class="hljs-number">1</span>];
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>Place the results into <code>B</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (size_t i = n - <span class="hljs-number">1</span>;; i--) {</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>Insert the element <code>A[i]</code> into <code>B</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		B[C[A[i]] - <span class="hljs-number">1</span>] = A[i];</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>Updated the counter - one less element to sort.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		C[A[i]]--;</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>Stop when the beginning of <code>A</code> is reached.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (!i) {
			<span class="hljs-keyword">break</span>;
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>Free the counters array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-built_in">free</span>(C);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>Counting sort <code>A</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">void</span> counting_sort(<span class="hljs-keyword">int</span> A[], size_t n, <span class="hljs-keyword">int</span> k)
{</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>The temporary output.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">int</span> *B = <span class="hljs-built_in">calloc</span>(n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>Sort <code>A</code> and place the result into <code>B</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	do_counting_sort(A, n, k, B);</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>Copy <code>B</code> to <code>A</code> and free <code>B</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-built_in">memcpy</span>(A, B, n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
	<span class="hljs-built_in">free</span>(B);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <h2 id="heap-sort">Heap sort</h2>

            </div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>Return the left child of <code>i</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">static</span> size_t left(size_t i)
{
	<span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>Return the right child of <code>i</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">static</span> size_t right(size_t i)
{
	<span class="hljs-keyword">return</span> left(i) + <span class="hljs-number">1</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>Return the parent of <code>i</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">static</span> size_t parent(size_t i)
{
	<span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>Satisfy the max-heap property on a tree rooted in <code>A[0]</code> where the subtrees
at <code>A[1]</code> and <code>A[2]</code> are max-heaps.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> max_heapify(<span class="hljs-keyword">int</span> A[], size_t n, size_t i)
{</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>The index of the greatest element from <code>A[0..2]</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	size_t M;</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>Compare the root with the left child.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (left(i) &lt; n &amp;&amp; A[i] &lt; A[left(i)]) {
		M = left(i);
	} <span class="hljs-keyword">else</span> {
		M = i;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>Compare the previous maximum with the right child.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (right(i) &lt; n &amp;&amp; A[M] &lt; A[right(i)]) {
		M = right(i);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>At this point <code>M</code> is the index of a maximum in <code>A[0..2]</code>. If <code>M == 0</code>
then <code>A</code> has the max-heap property and there&#39;s nothing to do.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (M == i) {
		<span class="hljs-keyword">return</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>Push the root element of <code>A</code> down the heap in the right direction and
recursively turn the subtree into a max-heap.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	swap(A[M], A[i]);

	max_heapify(A, n, M);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>Remove the maximum element of a heap and return it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> extract_max(<span class="hljs-keyword">int</span> A[], size_t n)
{</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>The maximum of a max-heap is by definition the root element.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">int</span> max = A[<span class="hljs-number">0</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>Replace the root with the last element and fix the max-heap property.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	A[<span class="hljs-number">0</span>] = A[n - <span class="hljs-number">1</span>];
	max_heapify(A, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>Return the maximum.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> max;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>Build a max-heap in-place given an array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> build_max_heap(<span class="hljs-keyword">int</span> A[], size_t n)
{</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>Nothing to do for an empty array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (!n) {
		<span class="hljs-keyword">return</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p><code>i</code> is the index of the root of a sub-heap. We start from the right
end of the array. This is equivalent to the bottom of the heap.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	size_t i = n - <span class="hljs-number">1</span>;

	<span class="hljs-keyword">do</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>Fix the max-heap property of a subtree rooted in <code>A[i]</code> and
move to the element to the next element.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		max_heapify(A, n, i);
	} <span class="hljs-keyword">while</span>(i-- &gt; <span class="hljs-number">0</span>);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>Sort an array using max-heaps.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">void</span> heap_sort(<span class="hljs-keyword">int</span> A[], size_t n)
{</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>Turn the input array into a max-heap.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	build_max_heap(A, n);</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>Repeatedly extract the maximum element and put it at the end of the
array. The elements <code>A[0..n - i - 1]</code> are the max-heap while
<code>A[n - i..n - 1]</code> are the sorted output array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; n; i++) {
		<span class="hljs-keyword">int</span> max = extract_max(A, n - i);
		A[n - i - <span class="hljs-number">1</span>] = max;
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <h2 id="radix-sort">Radix sort</h2>

            </div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>Return the <code>I</code>-th hexadecimal digit of <code>x</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> key(<span class="hljs-keyword">int</span> x, size_t I)
{
	<span class="hljs-keyword">return</span> (x &gt;&gt; (<span class="hljs-number">4</span> * I)) &amp; <span class="hljs-number">0x0F</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>A variant of insertion sort that uses hexadecimal digits as keys. Production
code should have a single insertion sort with parametrised key but this
isn&#39;t production, is it?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> radix_insertion_sort(<span class="hljs-keyword">int</span> A[], size_t n, size_t I)
{
	<span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">1</span>; i &lt; n; i++) {
		size_t j = i - <span class="hljs-number">1</span>;

		<span class="hljs-keyword">do</span> {
			<span class="hljs-keyword">if</span> (key(A[j], I) &gt; key(A[j + <span class="hljs-number">1</span>], I)) {
				swap(A[j], A[j + <span class="hljs-number">1</span>]);
			}
		} <span class="hljs-keyword">while</span>(j-- &gt; <span class="hljs-number">0</span>);
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>Sort <code>A</code> using radix sort. The algorithm relies on the fact that insertion
sort is stable. We sort multiple times using more significant digits in each
iteration of the loop. Insertion sort can be replaced with any other stable
sorting algorithm (i.e. preserving the order of elements with equal keys).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">void</span> radix_sort(<span class="hljs-keyword">int</span> A[], size_t n)
{
	<span class="hljs-keyword">for</span> (size_t I = <span class="hljs-number">0</span>; I &lt; <span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(*A) / <span class="hljs-number">4</span>; I++) {
		radix_insertion_sort(A, n, I);
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <h1 id="number-theory">Number theory</h1>

            </div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <h2 id="power-modulo-n">Power Modulo n</h2>

            </div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>Return <code>b^n mod m</code>. In order to avoid overflows the procedure reduces <code>b</code>
modulo <code>m</code> before entering the loop and after each iteration.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">int</span> pow_mod(<span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)
{
	<span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span> (b = b % m; n; n--) {
		result = (result * b) % m;
	}
	<span class="hljs-keyword">return</span> result;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>An alternative to the procedure above that uses binary exponentation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">int</span> binary_pow_mod(<span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)
{
	<span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span> (b = b % m; n &gt; <span class="hljs-number">0</span>; n &gt;&gt;= <span class="hljs-number">1</span>) {
		<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span>) {
			result = (result * b) % m;
		}
		b = (b * b) % m;
	}
	<span class="hljs-keyword">return</span> result;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <h2 id="greatest-common-divisor">Greatest Common Divisor</h2>

            </div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>Return the greatest common divisor of <code>a</code> and <code>b</code>. The procedure implements
the recursive Euclidean algorithm.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">int</span> recursive_euclidean_gcd(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)
{</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>Ignore the signs and ensure that <code>a</code> is greater than <code>b</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	a = <span class="hljs-built_in">abs</span>(a);
	b = <span class="hljs-built_in">abs</span>(b);
	<span class="hljs-keyword">if</span> (b &gt; a) {
		swap(a, b);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p>If <code>b</code> divides <code>a</code> then <code>b</code> is the GCD.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">int</span> r = a % b;
	<span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) {
		<span class="hljs-keyword">return</span> b;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>An expression of a mathematical fact that GCD(a, b) = GCD(b, r).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> recursive_euclidean_gcd(b, r);
}

<span class="hljs-keyword">int</span> iterative_euclidean_gcd(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)
{</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>Ignore the signs and ensure that <code>a</code> is greater than <code>b</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	a = <span class="hljs-built_in">abs</span>(a);
	b = <span class="hljs-built_in">abs</span>(b);
	<span class="hljs-keyword">if</span> (a &lt; b) {
		swap(a, b);
	}

	<span class="hljs-keyword">int</span> r;

	<span class="hljs-keyword">while</span> ((r = a % b) != <span class="hljs-number">0</span>) {
		a = b;
		b = r;
	}

	<span class="hljs-keyword">return</span> b;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <h2 id="least-common-multiple">Least Common Multiple</h2>

            </div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>Return the least common multiple of <code>a</code> and <code>b</code>. The implementation uses the
fact that LCM(a, b) GCD(a, b) = ab.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">int</span> lcm(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)
{
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a * b / recursive_euclidean_gcd(a, b));
}</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <h2 id="fermat-primarility-test">Fermat Primarility Test</h2>

            </div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>The test uses the fact that <code>a^p = a</code> modulo <code>p</code> if <code>p</code> is a prime number.
Therefore if the equality above doesn&#39;t hold for some <code>a</code> then <code>p</code> is not
a prime. However even when the equality holds for all <code>a</code>s it <em>does not</em>
mean that <code>p</code> is a prime. Composite numbers that pass the test are called
Carmichael numbers. The first such number is 561.</p>
<p>Return <code>true</code> if there&#39;s a chance that <code>p</code> is prime, <code>false</code> if it&#39;s
certainly not a prime.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">bool</span> fermat_prime(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> tests)
{
	<span class="hljs-keyword">while</span> (tests) {
		<span class="hljs-keyword">int</span> a = rand();
		<span class="hljs-keyword">if</span> (pow_mod(a, p - <span class="hljs-number">1</span>, p) != <span class="hljs-number">1</span>) {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		}
	}
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <h1 id="binary-trees">Binary trees</h1>

            </div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <h2 id="definition">Definition</h2>

            </div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <p>A binary tree is, by definition, a tree whose nodes have at most two
children. It&#39;s the simples type of a tree yet very useful. The traditional
names of subtrees are left and right subtree.</p>
<p>This data structure defines a single node of a tree. <code>key</code> is the value
stored at the node. <code>left_child</code> and <code>right_child</code> point to the subtrees. If
there&#39;s no corresponding subtree then the corresponding pointer is set to
<code>NULL</code>. A leaf node has both pointers set to <code>NULL</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">struct</span> binary_tree {
	<span class="hljs-keyword">int</span> key;
	<span class="hljs-keyword">struct</span> binary_tree *left_child;
	<span class="hljs-keyword">struct</span> binary_tree *right_child;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>A procedure used for traversing a tree. It&#39;s only argument is the key of the
currently visited node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> (*binary_tree_visitor)(<span class="hljs-keyword">int</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <h2 id="traversal">Traversal</h2>

            </div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>The three traversal algorithms below are the fundamental depth first
traversal algorithms. The left subtree is always visited before the right
subtree. However the current element is visited before the left tree (in
pre-order traveral), after the left but before right (in-order traversal) or
after the right tree (post-order traversal).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">void</span> traverse_preorder(<span class="hljs-keyword">struct</span> binary_tree *tree, binary_tree_visitor visitor)
{
	<span class="hljs-keyword">if</span> (!tree) {
		<span class="hljs-keyword">return</span>;
	}

	visitor(tree-&gt;key);
	traverse_preorder(tree-&gt;left_child, visitor);
	traverse_preorder(tree-&gt;right_child, visitor);
}

<span class="hljs-keyword">void</span> traverse_inorder(<span class="hljs-keyword">struct</span> binary_tree *tree, binary_tree_visitor visitor)
{
	<span class="hljs-keyword">if</span> (!tree) {
		<span class="hljs-keyword">return</span>;
	}

	traverse_preorder(tree-&gt;left_child, visitor);
	visitor(tree-&gt;key);
	traverse_preorder(tree-&gt;right_child, visitor);
}

<span class="hljs-keyword">void</span> traverse_postorder(<span class="hljs-keyword">struct</span> binary_tree *tree, binary_tree_visitor visitor)
{
	<span class="hljs-keyword">if</span> (!tree) {
		<span class="hljs-keyword">return</span>;
	}

	traverse_preorder(tree-&gt;left_child, visitor);
	traverse_preorder(tree-&gt;right_child, visitor);
	visitor(tree-&gt;key);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <h2 id="operations">Operations</h2>

            </div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>Return the number of nodes in a binary tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">int</span> binary_tree_size(<span class="hljs-keyword">struct</span> binary_tree *tree)
{</pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <p>An empty tree has size zero.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (!tree) {
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>The size of a non-empty tree has three components: the current node
(corresponding to <code>1</code>), the size of the left subtree and the size of the
right subtree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + binary_tree_size(tree-&gt;left_child) +
		binary_tree_size(tree-&gt;right_child);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <p>Return the maximum depth of a binary tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">int</span> binary_tree_max_depth(<span class="hljs-keyword">struct</span> binary_tree *tree)
{</pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <p>The depth of an empty tree is zero.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (!tree) {
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <p>The depth of the tree is one (corresponding to the current node) plus
the depth of a subtree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">int</span> left_max_depth = binary_tree_max_depth(tree-&gt;left_child);
	<span class="hljs-keyword">int</span> right_max_depth = binary_tree_max_depth(tree-&gt;right_child);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max(left_max_depth, right_max_depth);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <p>Return <code>true</code> if two trees have the same structure, <code>false</code> otherwise.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">bool</span> binary_tree_equal(<span class="hljs-keyword">struct</span> binary_tree *tree1, <span class="hljs-keyword">struct</span> binary_tree *tree2)
{</pre></div></div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <p>The tree is obviously equal to itself. This also handles the case of
empty trees.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (tree1 == tree2) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <p>A non-empty tree cannot be equal to an empty tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (!tree1 || !tree2) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <p>If the keys of the corresponding nodes are different then the trees
are different.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (tree1-&gt;key != tree2-&gt;key) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <p>If the keys are equal then both subtrees must be equal.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> binary_tree_equal(tree1-&gt;left_child, tree2-&gt;left_child) &amp;&amp;
		binary_tree_equal(tree1-&gt;right_child, tree2-&gt;right_child);
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
